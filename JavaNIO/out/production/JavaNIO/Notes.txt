- Channel: source reading or writing data from
- Buffer: where data is held before R/W - done automatically with NIO
- Need to make FileInput/OutputStream stream, and then call get channel
    - Each only open for either reading or writing
- When you make a buffer, need to specify the size of the buffer to determine how many bytes are read at one time
- Writing to the channel means reading from the buffer
- Methods in files class are sequential
- Files class from NIO
    - Use FileInputStream to get a channel
    - Can use readAllLines() to get the data from the file
    - Each Files.write is an isolated event, so expensive (use getBytes() because writes bytes not a string)
        - Need to pass parameter to append data instead of truncating existing data and starting again
- Buffer
    - Capacity: amount of elements it can contain
    - Index: position of next element that can be read/written
    - Mark: for reset(), will reset position to the mark
- ByteBuffer
    - flip() to reset buffer to 0, needed whenever switching from reading-writing
        - Also required when switching from reading from buffer and writing to channel
        - Potentially nothing happens with read/write because at the end of the buffer
        - Call with each access of the buffer
    - Make byte[] from string getBytes() and then wrap in ByteBuffer
    - Starts at position 0, mark is undefined, capacity is byte array you passed in
    - allocate() to reserve size in the buffer, and then use put()
        - Wrap() resets the position to 0 automatically for byte arrays, and array passed automatically backs the buffer
    - Using channel.read() will read from the channel and write to the buffer, and getInt() will read from the buffer
    - When put data into buffer, it changes the buffers position. Need to reset the position to 0 if you want it to start reading before a write
    - After you write, index is at the length of everything that has been written. So if you wrote an int would be at 4 bytes
    - Can pass second argument to put() to specify which index to start read/write
    - Buffer overflow when try to put too much data thn was allocated in the buffer
- Channel and output stream need to be closed unless using try-with-resource
- When using a byte array to back the buffer, changes to read/write will modify that array
    - Buffer not same as array in memory. If you write to the buffer, from the channel, will modify the array backing the buffer
- Can use buffer.array() to get the byte array backing the buffer
- Absolute vs Relative reads
    - get/put calls from buffer without params are relative based on where index is in buffer, can pass parameter
    - Would not need to flip buffer back to start because can get(0) to start from beginning
    - Absolute indices then position is not updated





