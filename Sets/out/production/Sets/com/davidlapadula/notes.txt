
- All collections can take a collection in constructor to create new collection; suggested to either make new collection when implementing interface or pass collection into constructor to make a new collection anyway
- Only suggestion because this is interface (no constructor)
- List: ordered without duplicates
- Set: is a generic interface, NO DUPLICATES
- Add, remove, clear, size, isEmpty, contains, methods
- Cannot key from index; need to loop over it
- Set cannot contain element of itself
- Hashset: uses hashes to store items. Uses implementation of Hashmap by using key (element added to set) and dummy object as value)
- Operations are very fast
- Has iteration capability
- Set theory
    - Union is set containing all elements from combining sets; because sets have no duplicates each element only appears once even if present in both sets, this is possible with Set interface
    - addAll() method can create set union
- Only REFERENCES to objects stored in the set, could appear in many sets/maps with only 1 instance
    - Reference to any data type (String, or Class ...) is the same size in memory. So only storing name instead of class adds complexity with no gain because need to retrieve it after
- If use own class for Key or Value, need to override equal() or else will allow duplicates because not evaluating as equal. If two objects compare equal must also override hashCode because equal objects must have the same hash
    - Base classes only use basic referential equality that only checks if reference is the same
    - When object generates hashcode that exists, uses compare to see if it is already thee, which is why it must be overridden
- In hashed collection, two equal objects must have same hashcode, but unequal objects do not need to have different hashes
    - Added object must generate same hashcode as others that are equal to it (hasCode method), and this hasCode will be used to find where to put object, and compare will test what is already there
- Performance of hashing found in the use of different 'buckets' for each hash. If not using hash for each bucket, and is only 1 bucket, need to compare for every element and the performance drops off
- When overriding equals() CANNOT return true if class being compared is subclass of itself
    - Unless class is final, in which case cannot be subclassed. Class that is final CANNOT be subclassed
    - Equals needs to be symmetrical; A must equal B and B must equal A - issue with subclass when sub is instance of parent but parent is not instance of sub
        - Avoid this by making finals equal in the base class when so cannot be overridden
    - Rules for handling comparisons of subclass and base class:
        - If subclass does not have methods that change equality, allow subclass but equals() needs to be final to prevent being overridden
        - Subclass is different object, then override equals to make comparison between sub and base class return False
        - If neither true, prevent sub classing and force to use composition
- Make own class that is immutable and can be used as a key in map or element in a set
- If IS NOT immutable, need to override equals() and hashcode() to prevent odd behaviour and make sure elements get added correctly
- Bulk operations allow algebraic operations on sets
- Are destructive, they modify the set they are called upon
- Set Theory
    - Symmetric difference: retainAll() Union - intersection elements that appear in one or other but not both
    - Asymmetric difference: removeAll() - removes all the elements that are in the other set
    - containsAll() - is one set a superset of another. Does not modify, so not destructive
- When try to print object, toString automatically gets called, so if override it then that method will be called