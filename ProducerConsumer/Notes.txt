- Thread Safe
    - Thread calls method in class, not other threads can call method in class until first thread executed method
    - But multiple methods in synchronized class can be run by different threads
    - Thread can be suspended at random
- Use Thread.sleep as simulation to give other thread access before it runs again
- Synchronize on the instance that is being shared
    - Also use synchronize on whole block of critical code
    - Drawbacks of synchronization
    - Block must be all in the same method
        - Intrinsic lock not available, when hit sync code either execute from getting lock or wait. Cannot timeout if waited too long
        - Multiple threads waiting for lock has no order, when thread was locked has no effect on when it gets lock
- Threads that are locked waiting for object cannot be interrupted, they need the lock from the object before they carry on
- Instead of sync. can use 'Lock' interface from 'Concurrent' class
-Reentrant Lock
    - If thread holding lock reaches object that requires same lock, it can continue to execute
    - Threads need to compete for the same lock to prevent interference
    - use lock() and unlock() before/after code you want to be locked, just like using synchronized block
        - If calls lock() and it is not available, will sleep until it is available
        - BUT need to call unlock() as it will not be released automatically
    - Reentrant tracks how many times got lock, need to unlock(0 as many times as locked(). Not unlocked until lock count reaches 0
