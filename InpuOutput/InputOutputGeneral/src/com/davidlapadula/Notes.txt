IO
    - Byte or character data
    - Character data can be read and edited in file, binary cannot 
    - Binary for variable or classes, Character for things that need to be edited
    - Main problems could be that the file is read only, or improper persmissions
    - Finally clause runs after everything, appear after stack trace print because call stack only executes when it is done
    - Class has to be loaded BEFORE main method runs
Sequential: data in defined order in sequence
    - Like String
Random access: can jump around file and read/write wherever you want. Can be read from wherever
    - Like database
- Need to implement all abstract methods of interface
- Static initialization block for data that needs to share all instances of the same data across classes
    - Runs when the data is loaded
- Need to close a stream - file can be locked or can get resource leak
- Cannot ignore checked exception
- Alternative to catching exception is to throw them back up the call stack
    - Throw exception up call stack so calling method can handle it
    - Specify that function throws method
        - This way calling method can either catch the exception or throw it back up the stack trace
- Throw own exception to test
- try-with-resources
    - Syntax is try(<resource>) initialization code in try parentheses
    - Put any stream in as resource and will ensure it is closed and that exception is thrown
    - Difference to try/finally: if exception thrown from try and stream close in try-with-resources only try exception will be thrown up the stack, instead of exception thron from finally
        - First error is probably the main problem
- New Scanner (<where to read data from>); could be system.in or new FileReader depending on when data is coming from
    - Source for scanner must implement 'Readable'
    - Stream object implements 'Closeable', than close method of that class will automatically call close when the stream is done
- Buffered Reader
    - Reads characters and buffers them into array
    - Scanner parses input data, BR just reads sequences of characters and should be used if working with multiple threads
    - Prevents excessive disk reading, only read if buffer is empty, otherwise read from memory buffer
- Buffered Writer
    - Data only put into buffer, and only written when buffer is full
    - Prevents writing data often, which is slow
- Static initialization created when class is loaded, cannot throw checked exception because potentially no class to catch it
- Byte Streams
    - Dealing with binary data - do not need to parse data
    - Byte stream can be used for any primitve type
    - Builds classes from reading the bytes
    - DataOutputStream, BufferedOutputStream, FileOutputStream are the classes to work with for working with binary data
    - Methods to write all primitive types from Binary data
    - To parsing to get values String, Stream class deals with it
    - Throw EOFException, subclass of IOException. End of file exception thrown when the stream runs out of data
    - Object Input/Output stream
        - Assembled into format that can be stored and then reassembled
        - Serialization (interface): serialize object into storage to read it again
        - Serial version UID when Serialization implemented: like id for that Serialization
            - Needed for reading serialized data, must be the same as which it was serialized with
            - InvalidClassException when classes dont match
        - When object is Serializable, all its properties need to be Serializable as well, or else need to write code to serialize yourself
        - ObjectInput/OutputStream implements DataInput/Output interface: declarations for write/read methods for binary data
            - Read/Write object takes care of its fields. but needs to be cats as corresponding class when it is read
            - ClassNotFoundException: when object output stream tries to read serialized class that it cant find
    - Serialized file will only contain 1 copy of class instance; unique within files but NOT across files
- RandomAccessFile
    - Storing lots of data, need to jump to place in file where the data we need is
    - Offset: byte location in file
    - File point: where next read/write starts from
        - Advanced by amount of bytes read/written
    - Each set of data, is a record
        - Each record occupies same bytes, easy to calculate place, if different need INDEX to store offset and record length
    - Index to read location
        - Index: uniqueId for record, offset for record, and record length
        - Load index into memory instead of accessing disk
